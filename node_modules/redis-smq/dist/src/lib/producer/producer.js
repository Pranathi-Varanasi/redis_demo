"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Producer = void 0;
const message_1 = require("../message/message");
const events_1 = require("../../common/events/events");
const base_1 = require("../base");
const redis_smq_common_1 = require("redis-smq-common");
const redis_keys_1 = require("../../common/redis-keys/redis-keys");
const message_not_published_error_1 = require("./errors/message-not-published.error");
const message_already_published_error_1 = require("./errors/message-already-published.error");
const redis_client_1 = require("../../common/redis-client/redis-client");
const schedule_message_1 = require("./schedule-message");
const producer_not_running_error_1 = require("./errors/producer-not-running.error");
const types_1 = require("../../../types");
const direct_exchange_1 = require("../exchange/direct-exchange");
const queue_1 = require("../queue-manager/queue");
class Producer extends base_1.Base {
    constructor() {
        super(...arguments);
        this.initProducerEventListeners = (cb) => {
            this.registerEventListeners(this.config.eventListeners.producerEventListeners, cb);
        };
    }
    goingUp() {
        return super.goingUp().concat([this.initProducerEventListeners]);
    }
    enqueue(redisClient, queue, message, cb) {
        var _a;
        message.getRequiredMessageState().setPublishedAt(Date.now());
        const { keyQueueSettings, keyQueuePendingPriorityMessages, keyQueuePendingPriorityMessageWeight, keyQueuePending, } = redis_keys_1.redisKeys.getQueueKeys(queue);
        redisClient.runScript(redis_client_1.ELuaScriptName.PUBLISH_MESSAGE, [
            keyQueueSettings,
            types_1.EQueueSettingType.QUEUE_TYPE,
            keyQueuePendingPriorityMessages,
            keyQueuePendingPriorityMessageWeight,
            keyQueuePending,
        ], [
            message.getRequiredId(),
            JSON.stringify(message),
            (_a = message.getPriority()) !== null && _a !== void 0 ? _a : '',
        ], (err, reply) => {
            if (err)
                cb(err);
            else if (reply !== 'OK')
                cb(new message_not_published_error_1.MessageNotPublishedError(String(reply)));
            else
                cb();
        });
    }
    produceMessage(redisClient, message, queue, cb) {
        const messageId = message
            .setDestinationQueue(queue)
            .getSetMessageState()
            .getId();
        if (message.isSchedulable())
            (0, schedule_message_1.scheduleMessage)(redisClient, message, (err) => {
                if (err)
                    cb(err);
                else {
                    this.logger.info(`Message (ID ${messageId}) has been scheduled.`);
                    cb();
                }
            });
        else
            this.enqueue(redisClient, queue, message, (err) => {
                if (err)
                    cb(err);
                else {
                    this.logger.info(`Message (ID ${messageId}) has been published.`);
                    this.emit(events_1.events.MESSAGE_PUBLISHED, message);
                    cb();
                }
            });
    }
    produce(message, cb) {
        if (!this.powerManager.isUp())
            cb(new producer_not_running_error_1.ProducerNotRunningError());
        else {
            if (message.getMessageState())
                cb(new message_already_published_error_1.MessageAlreadyPublishedError());
            else {
                const callback = (err, messages = []) => {
                    if (err)
                        cb(err);
                    else
                        cb(null, { scheduled: false, messages });
                };
                const redisClient = this.getSharedRedisClient();
                const exchange = message.getRequiredExchange();
                if (exchange instanceof direct_exchange_1.DirectExchange) {
                    const queue = queue_1.Queue.getParams(this.config, exchange.getBindingParams());
                    this.produceMessage(redisClient, message, queue, (err) => callback(err, [message]));
                }
                else {
                    exchange.getQueues(redisClient, this.config, (err, queues) => {
                        if (err)
                            cb(err);
                        else if (!(queues === null || queues === void 0 ? void 0 : queues.length))
                            cb(new message_not_published_error_1.MessageNotPublishedError(`The exchange (${exchange.constructor.name}) does not match any queue.`));
                        else {
                            const messages = [];
                            redis_smq_common_1.async.eachOf(queues, (queue, index, done) => {
                                const msg = message_1.Message.createFromMessage(message, true);
                                this.produceMessage(redisClient, msg, queue, (err) => {
                                    if (err)
                                        done(err);
                                    else {
                                        messages.push(msg);
                                        done();
                                    }
                                });
                            }, (err) => callback(err, messages));
                        }
                    });
                }
            }
        }
    }
}
exports.Producer = Producer;
//# sourceMappingURL=producer.js.map