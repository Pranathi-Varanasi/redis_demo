"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Queue = void 0;
const types_1 = require("../../../types");
const redis_keys_1 = require("../../common/redis-keys/redis-keys");
const queue_exists_error_1 = require("./errors/queue-exists.error");
const queue_not_found_error_1 = require("./errors/queue-not-found.error");
const delete_queue_transaction_1 = require("./delete-queue-transaction");
const redis_smq_common_1 = require("redis-smq-common");
const redis_client_1 = require("../../common/redis-client/redis-client");
const empty_callback_reply_error_1 = require("redis-smq-common/dist/src/errors/empty-callback-reply.error");
class Queue {
    constructor(config, redisClient, logger) {
        this.config = config;
        this.redisClient = redisClient;
        this.logger = logger;
    }
    create(queue, priorityQueuing, cb) {
        const queueType = priorityQueuing
            ? types_1.EQueueType.PRIORITY_QUEUE
            : types_1.EQueueType.LIFO_QUEUE;
        this.save(queue, queueType, cb);
    }
    save(queue, queueType, cb) {
        const queueParams = Queue.getParams(this.config, queue);
        const { keyQueues, keyNsQueues, keyNamespaces, keyQueueSettings } = redis_keys_1.redisKeys.getQueueKeys(queueParams);
        const queueIndex = JSON.stringify(queueParams);
        this.redisClient.runScript(redis_client_1.ELuaScriptName.CREATE_QUEUE, [
            keyNamespaces,
            keyNsQueues,
            keyQueues,
            keyQueueSettings,
            types_1.EQueueSettingType.QUEUE_TYPE,
        ], [queueParams.ns, queueIndex, queueType], (err, reply) => {
            if (err)
                cb(err);
            else if (!reply)
                cb(new queue_exists_error_1.QueueExistsError());
            else
                this.getSettings(queueParams, (err, settings) => {
                    if (err)
                        cb(err);
                    else if (!settings)
                        cb(new empty_callback_reply_error_1.EmptyCallbackReplyError());
                    else
                        cb(null, { queue: queueParams, settings });
                });
        });
    }
    getSettings(queue, cb) {
        Queue.getSettings(this.config, this.redisClient, queue, cb);
    }
    exists(queue, cb) {
        Queue.exists(this.config, this.redisClient, queue, cb);
    }
    list(cb) {
        Queue.list(this.redisClient, cb);
    }
    delete(queue, cb) {
        const queueParams = Queue.getParams(this.config, queue);
        (0, delete_queue_transaction_1.initDeleteQueueTransaction)(this.config, this.redisClient, queueParams, undefined, (err, multi) => {
            if (err)
                cb(err);
            else if (!multi)
                cb(new redis_smq_common_1.errors.EmptyCallbackReplyError());
            else
                multi.exec((err) => cb(err));
        });
    }
    static getParams(config, queue) {
        const queueParams = typeof queue === 'string' ? { name: queue } : queue;
        const name = redis_keys_1.redisKeys.validateRedisKey(queueParams.name);
        const ns = queueParams.ns
            ? redis_keys_1.redisKeys.validateNamespace(queueParams.ns)
            : config.namespace;
        return {
            name,
            ns,
        };
    }
    static parseSettings(raw) {
        const queueSettings = {
            priorityQueuing: false,
            type: types_1.EQueueType.LIFO_QUEUE,
            exchange: null,
            rateLimit: null,
        };
        for (const key in raw) {
            if (key === types_1.EQueueSettingType.PRIORITY_QUEUING && JSON.parse(raw[key])) {
                queueSettings.type = types_1.EQueueType.PRIORITY_QUEUE;
                queueSettings.priorityQueuing = true;
            }
            if (key === types_1.EQueueSettingType.QUEUE_TYPE) {
                queueSettings.type = Number(raw[key]);
                if (queueSettings.type === types_1.EQueueType.PRIORITY_QUEUE) {
                    queueSettings.priorityQueuing = true;
                }
            }
            if (key === types_1.EQueueSettingType.RATE_LIMIT) {
                queueSettings.rateLimit = JSON.parse(raw[key]);
            }
            if (key === types_1.EQueueSettingType.EXCHANGE) {
                queueSettings.exchange = raw[key];
            }
        }
        return queueSettings;
    }
    static getSettings(config, redisClient, queue, cb) {
        const queueParams = Queue.getParams(config, queue);
        const { keyQueueSettings } = redis_keys_1.redisKeys.getQueueKeys(queueParams);
        redisClient.hgetall(keyQueueSettings, (err, reply) => {
            if (err)
                cb(err);
            else if (!reply || !Object.keys(reply).length)
                cb(new queue_not_found_error_1.QueueNotFoundError());
            else {
                const queueSettings = Queue.parseSettings(reply);
                cb(null, queueSettings);
            }
        });
    }
    static list(redisClient, cb) {
        const { keyQueues } = redis_keys_1.redisKeys.getMainKeys();
        redisClient.sscanFallback(keyQueues, (err, reply) => {
            if (err)
                cb(err);
            else if (!reply)
                cb(new redis_smq_common_1.errors.EmptyCallbackReplyError());
            else {
                const messageQueues = reply.map((i) => JSON.parse(i));
                cb(null, messageQueues);
            }
        });
    }
    static exists(config, redisClient, queue, cb) {
        const queueParams = Queue.getParams(config, queue);
        const { keyQueues } = redis_keys_1.redisKeys.getMainKeys();
        redisClient.sismember(keyQueues, JSON.stringify(queueParams), (err, reply) => {
            if (err)
                cb(err);
            else
                cb(null, !!reply);
        });
    }
}
exports.Queue = Queue;
//# sourceMappingURL=queue.js.map